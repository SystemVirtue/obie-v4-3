<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jukebox Player</title>
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#000000">
  <script src="https://www.youtube.com/iframe_api"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    
    #player-container {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    #player {
      width: 100%;
      height: 100%;
      opacity: 1;
      transition: opacity 0.05s ease-out;
    }
    
    #now-playing {
      display: none !important;
    }
    
    .status {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 12px 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 20px;
      font-size: 0.9rem;
      backdrop-filter: blur(10px);
    }
    
    .status.connected::before {
      content: '‚óè';
      color: #4ade80;
      margin-right: 8px;
      animation: blink 2s infinite;
    }
    
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
  </style>
</head>
<body>
  <div class="status connected" id="status">Ready</div>
  
  <div id="player-container">
    <div id="player"></div>
    <div id="now-playing" style="display:none">
      <h2 id="track-title">Loading...</h2>
      <div id="queue-info">Queue: <span id="queue-count">0</span> songs</div>
    </div>
  </div>

  <script>
    console.log('[Player] Initializing...');
    
    // ========== VARIABLE DECLARATIONS ==========
    let player = null;
    let currentVideoId = '';
    let isPlaying = false;
    let testMode = false;
    let testModeTimeout = null;
    
    // ========== YOUTUBE API CALLBACK ==========
    window.onYouTubeIframeAPIReady = function() {
      console.log('[YouTube] IFrame API Ready');
      initializePlayer();
    };

    function initializePlayer() {
      console.log('[Player] Creating YouTube player');
      player = new YT.Player('player', {
        height: '100%',
        width: '100%',
        videoId: '',
        playerVars: {
          autoplay: 1,
          controls: 1,
          modestbranding: 1,
          rel: 0,
          fs: 1,
          iv_load_policy: 3
        },
        events: {
          onReady: onPlayerReady,
          onStateChange: onPlayerStateChange,
          onError: onPlayerError
        }
      });
    }

    function onPlayerReady(event) {
      console.log('[Player] Ready');
      sendStatus('ready', 'Player initialized');
      
      // Check if there's a pending command
      checkForCommands();
    }

    function onPlayerStateChange(event) {
      console.log('[Player] State changed:', event.data);
      
      const stateMap = {
        '-1': 'unstarted',
        '0': 'ended',
        '1': 'playing',
        '2': 'paused',
        '3': 'buffering',
        '5': 'cued'
      };
      
      const state = stateMap[event.data] || 'unknown';
      
      if (event.data === YT.PlayerState.PLAYING) {
        isPlaying = true;
        const videoData = player.getVideoData();
        sendStatus('playing', videoData.title, currentVideoId);
        document.getElementById('now-playing').style.display = 'block';
        document.getElementById('track-title').textContent = videoData.title || 'Now Playing';
      } else if (event.data === YT.PlayerState.PAUSED) {
        isPlaying = false;
        sendStatus('paused', 'Paused');
      } else if (event.data === YT.PlayerState.ENDED) {
        isPlaying = false;
        
        // Check if in test mode
        if (testMode) {
          console.log('[Player] Test mode complete');
          sendStatus('testModeComplete', 'Test mode complete', currentVideoId);
        } else {
          sendStatus('ended', 'Video ended', currentVideoId);
        }
        
        currentVideoId = '';
      } else if (event.data === YT.PlayerState.BUFFERING) {
        sendStatus('buffering', 'Buffering...');
      }
    }

    function onPlayerError(event) {
      console.error('[Player] Error:', event.data);
      const errorMessages = {
        2: 'Invalid video ID',
        5: 'HTML5 player error',
        100: 'Video not found',
        101: 'Video not allowed',
        150: 'Video not allowed'
      };
      
      const message = errorMessages[event.data] || 'Unknown error';
      sendStatus('error', message, currentVideoId);
      
      // Auto-skip on error
      currentVideoId = '';
    }

    function sendStatus(status, title = '', videoId = '') {
      const statusData = {
        status,
        title,
        videoId: videoId || currentVideoId,
        id: videoId || currentVideoId,
        timestamp: Date.now()
      };
      
      console.log('[Player] Sending status:', statusData);
      localStorage.setItem('jukeboxStatus', JSON.stringify(statusData));
    }

    function checkForCommands() {
      const commandStr = localStorage.getItem('jukeboxCommand');
      if (commandStr) {
        try {
          const command = JSON.parse(commandStr);
          processCommand(command);
        } catch (e) {
          console.error('[Player] Error parsing command:', e);
        }
      }
    }

    function processCommand(command) {
      console.log('[Player] Processing command:', command);
      
      if (!player) {
        console.warn('[Player] Player not ready yet');
        return;
      }
      
      switch (command.action) {
        case 'play':
          if (command.videoId && command.videoId !== currentVideoId) {
            console.log('[Player] Loading video:', command.videoId);
            currentVideoId = command.videoId;
            testMode = command.testMode || false;
            
            // Clear any existing test mode timeout
            if (testModeTimeout) {
              clearTimeout(testModeTimeout);
              testModeTimeout = null;
            }
            
            player.loadVideoById({
              videoId: command.videoId,
              startSeconds: 0
            });
            
            // Reset opacity for new video
            const playerElement = document.getElementById('player');
            if (playerElement) {
              playerElement.style.opacity = '1';
            }
            
            // Set video quality if specified
            if (command.videoQuality && command.videoQuality !== 'auto') {
              // Map our quality names to YouTube quality levels
              const qualityMap = {
                'small': 'small',
                'medium': 'medium', 
                'large': 'large',
                'hd720': 'hd720',
                'hd1080': 'hd1080'
              };
              const ytQuality = qualityMap[command.videoQuality];
              if (ytQuality) {
                // Set quality after a short delay to ensure video is loaded
                setTimeout(() => {
                  try {
                    player.setPlaybackQuality(ytQuality);
                    console.log('[Player] Set video quality to:', ytQuality);
                  } catch (e) {
                    console.warn('[Player] Could not set video quality:', e);
                  }
                }, 1000);
              }
            }
            
            document.getElementById('track-title').textContent = command.title || 'Loading...';
            document.getElementById('now-playing').style.display = 'block';
            
            // Update queue count if provided
            if (command.queueCount !== undefined) {
              document.getElementById('queue-count').textContent = command.queueCount;
            }
            
            // If test mode, set timeout to fade out after 20 seconds
            if (testMode) {
              console.log('[Player] Test mode enabled - will fade out after 20 seconds');
              testModeTimeout = setTimeout(() => {
                console.log('[Player] Test mode timeout - fading out');
                fadeOutAndComplete();
              }, 20000);
            }
          } else if (!command.videoId) {
            player.playVideo();
          }
          break;
          
        case 'pause':
          player.pauseVideo();
          break;
          
        case 'fadeOut':
          fadeOutAndComplete();
          break;
          
        case 'fadeOutAndBlack':
          fadeOutAndComplete();
          break;
          
        case 'volume':
          if (command.volume !== undefined) {
            player.setVolume(command.volume);
          }
          break;
          
        case 'moveWindow':
          if (command.x !== undefined && command.y !== undefined) {
            window.moveTo(command.x, command.y);
            console.log('[Player] Moved window to:', command.x, command.y);
            if (command.width && command.height) {
              window.resizeTo(command.width, command.height);
              console.log('[Player] Resized window to:', command.width, command.height);
            }
          }
          break;
          
        case 'fullscreen':
          if (command.enable !== false) {
            document.documentElement.requestFullscreen().catch(e => {
              console.warn('[Player] Could not enter fullscreen:', e);
            });
          } else {
            document.exitFullscreen().catch(e => {
              console.warn('[Player] Could not exit fullscreen:', e);
            });
          }
          break;
          
        default:
          console.warn('[Player] Unknown command:', command.action);
      }
      
      // Clear the command after processing to prevent re-processing
      localStorage.removeItem('jukeboxCommand');
    }

    function fadeOutAndComplete() {
      console.log('[Player] Fading out with volume and opacity...');
      
      // Clear test mode timeout if exists
      if (testModeTimeout) {
        clearTimeout(testModeTimeout);
        testModeTimeout = null;
      }
      
      const startVolume = player.getVolume();
      const playerElement = document.getElementById('player');
      const fadeSteps = 40; // 40 steps * 50ms = 2 seconds
      const fadeInterval = 50; // ms per step
      let currentStep = 0;
      
      const fadeTimer = setInterval(() => {
        currentStep++;
        const progress = currentStep / fadeSteps;
        
        // Fade volume from startVolume to 0
        const newVolume = startVolume * (1 - progress);
        player.setVolume(Math.max(0, newVolume));
        
        // Fade opacity from 1 to 0
        const newOpacity = 1 - progress;
        if (playerElement) {
          playerElement.style.opacity = Math.max(0, newOpacity);
        }
        
        if (currentStep >= fadeSteps) {
          clearInterval(fadeTimer);
          player.pauseVideo();
          player.setVolume(startVolume); // Restore volume for next song
          
          // Reset opacity for next song
          if (playerElement) {
            playerElement.style.opacity = '1';
          }
          
          sendStatus('fadeComplete', 'Fade complete', currentVideoId);
          currentVideoId = '';
        }
      }, fadeInterval);
    }

    // ========== STORAGE EVENT LISTENER & POLLING ==========
    // Listen for commands from the main window
    window.addEventListener('storage', (event) => {
      if (event.key === 'jukeboxCommand' && event.newValue) {
        try {
          const command = JSON.parse(event.newValue);
          processCommand(command);
        } catch (e) {
          console.error('[Player] Error parsing storage command:', e);
        }
      }
    });
    
    // CRITICAL: Storage events don't fire in same window - add polling
    let lastCommand = localStorage.getItem('jukeboxCommand');
    setInterval(() => {
      const currentCommand = localStorage.getItem('jukeboxCommand');
      if (currentCommand !== lastCommand) {
        lastCommand = currentCommand;
        if (currentCommand) {
          try {
            const command = JSON.parse(currentCommand);
            console.log('[Player] Polling detected new command:', command);
            processCommand(command);
          } catch (e) {
            console.error('[Player] Error parsing polled command:', e);
          }
        }
      }
    }, 250); // Check every 250ms

    // ========== WINDOW POSITION MANAGEMENT ==========
    function saveWindowPosition() {
      try {
        const position = {
          x: window.screenX || window.screenLeft,
          y: window.screenY || window.screenTop,
          width: window.outerWidth,
          height: window.outerHeight
        };
        localStorage.setItem('PLAYER_WINDOW_POSITION', JSON.stringify(position));
        console.log('[Player] Saved window position:', position);
      } catch (e) {
        console.warn('[Player] Could not save window position:', e);
      }
    }

    function loadWindowPosition() {
      try {
        const saved = localStorage.getItem('PLAYER_WINDOW_POSITION');
        if (saved) {
          const position = JSON.parse(saved);
          if (position.x !== undefined && position.y !== undefined && 
              position.width && position.height) {
            window.moveTo(position.x, position.y);
            window.resizeTo(position.width, position.height);
            console.log('[Player] Restored window position:', position);
          }
        }
      } catch (e) {
        console.warn('[Player] Could not load window position:', e);
      }
    }

    // Load position on window load
    window.addEventListener('load', loadWindowPosition);

    // Save position on resize/move
    let saveTimeout = null;
    function debouncedSave() {
      if (saveTimeout) clearTimeout(saveTimeout);
      saveTimeout = setTimeout(saveWindowPosition, 500);
    }

    window.addEventListener('resize', debouncedSave);
    window.addEventListener('move', debouncedSave);

    // ========== PERIODIC STATUS UPDATE ==========
    setInterval(() => {
      if (player && isPlaying) {
        try {
          const currentTime = player.getCurrentTime();
          const duration = player.getDuration();
          const videoData = player.getVideoData();
          
          // Send periodic update
          sendStatus('playing', videoData.title, currentVideoId);
        } catch (e) {
          // Ignore errors during periodic updates
        }
      }
    }, 5000);

    // ========== INITIAL STATUS ==========
    console.log('[Player] Ready and waiting for YouTube API');
  </script>
</body>
</html>
